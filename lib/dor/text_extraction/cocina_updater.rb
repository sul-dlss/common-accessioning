# frozen_string_literal: true

module Dor
  module TextExtraction
    # Update Cocina structural metadata with Abbyy output files that have been added to a workspace directory.
    #
    # The logic for updating the Cocina is:
    #
    # 1. Look at each file in the workspace's content directory.
    # 2. If an OCR file will overwrite an existing file in Cocina ensure that the file to be
    #    overwritten was generated by SDR and has not been corrected.
    # 2. For each file get the file name "stem": e.g. for "abc123.xml" the stem is "abc123".
    # 3. Look in the Cocina structural metadata for a Resource containing a file with the
    #    same stem, e.g. "abc123.tiff".
    # 4. If a match is found add the new file to the Resource.
    # 5. If a match wasn't found add it to a new Resource.
    #
    # rubocop:disable Style/ClassLength
    class CocinaUpdater
      # @param dro [Cocina::Models::Dro] the object metadata to update in place
      # @param workspace_dir [String] the path where the new files to add are
      def self.update(dro:, workspace_dir:)
        CocinaUpdater.new(dro:, workspace_dir:).update
      end

      def initialize(dro:, workspace_dir:)
        @dro = dro
        @new_resources = []
        @workspace_dir = Pathname.new(workspace_dir)
      end

      def update
        rename_document_pdf
        update_cocina

        @dro
      end

      private

      # update the cocina with new files from the workspace
      def update_cocina
        content_dir.children.sort.each do |file|
          next if file.basename.to_s.start_with?('.')

          if file.basename.to_s.match(/#{bare_druid}\.(pdf|txt)$/)
            add_file_to_new_resource(file)
          else
            add_file_to_resource(file)
          end
        end
      end

      # Rename the PDF that was generated for an Item of type document
      # TODO: maybe xml_ticket_create.rb should be adjusted to create it this way?
      def rename_document_pdf
        file = find_workspace_file("#{bare_druid}.pdf")
        return unless file && document?

        new_filename = content_dir + "#{bare_druid}-generated.pdf"
        file.rename(new_filename)

        add_file_to_new_resource(new_filename)
      end

      def add_file_to_resource(path)
        if file_in_cocina?(path)
          guard_overwrite(path)
        else
          find_resource(path).structural.contains.push(file(path))
        end
      end

      def add_file_to_new_resource(path)
        @dro.structural.contains.push(
          Cocina::Models::FileSet.new(
            externalIdentifier: resource_identifier,
            type: resource_type(path),
            version: @dro.version,
            label: resource_label(path),
            structural: { contains: [file(path)] }
          )
        )
      end

      def file_in_cocina?(path)
        find_cocina_file(path) ? true : false
      end

      def find_cocina_file(path)
        dro_files.find { |file| file.filename == path.basename.to_s }
      end

      def dro_files
        # TODO: replace with Cocina::Models::Utils.files when that's available
        @dro.structural.contains.flat_map do |fileset|
          fileset.structural.contains
        end
      end

      def find_workspace_file(filename)
        path = content_dir + filename
        path.exist? ? path : nil
      end

      # prevent non SDR generated OCR and corrected OCR from being ovewritten by
      # removing it from the workspace
      def guard_overwrite(path)
        file = find_cocina_file(path)
        path.delete unless file.sdrGeneratedText == true && file.correctedForAccessibility == false
      end

      # Find a Cocina resource (aka fileset) for the given path
      # by looking for a resource that has a matching filename "stem".
      # @param path {String} - the path to look for
      # @return {FileSet, nil} - the FileSet or nil if it is not found
      def find_resource(path)
        file_stem = stem(path)
        @dro.structural.contains.detect do |resource|
          resource.structural.contains.detect do |file|
            stem(file.filename) == file_stem
          end
        end
      end

      # rubocop:disable Style/MethodLength
      def file(path)
        object_file = ::Assembly::ObjectFile.new(path)
        Cocina::Models::File.new(
          externalIdentifier: file_identifier,
          label: object_file.filename,
          use: 'transcription',
          sdrGeneratedText: true,
          correctedForAccessibility: false,
          type: Cocina::Models::ObjectType.file,
          filename: object_file.filename,
          version: @dro.version,
          hasMimeType: object_file.mimetype,
          hasMessageDigests: message_digests(object_file),
          size: object_file.filesize,
          access:,
          administrative:
        )
      end
      # rubocop:enable Style/MethodLength

      def access
        {
          view: 'world',
          download: 'world'
        }
      end

      def administrative
        {
          publish: true,
          sdrPreserve: true,
          shelve: true
        }
      end

      def message_digests(object_file)
        [
          {
            type: 'md5',
            digest: object_file.md5
          },
          {
            type: 'sha1',
            digest: object_file.sha1
          }
        ]
      end

      def resource_label(path)
        extension = path.extname
        if extension == '.txt'
          'Plain text OCR (uncorrected)'
        elsif extension == '.pdf' && document?
          'PDF (with automated OCR)'
        elsif extension == '.pdf'
          'Full PDF'
        else
          raise "Unable to determine resource label for #{path}"
        end
      end

      def resource_type(path)
        if path.extname == '.pdf' && document?
          Cocina::Models::FileSetType.document
        else
          Cocina::Models::FileSetType.object
        end
      end

      def stem(path)
        File.basename(path, '.*').to_s
      end

      def file_identifier
        "https://cocina.sul.stanford.edu/file/#{SecureRandom.uuid}"
      end

      def resource_identifier
        "#{bare_druid}_#{@dro.structural.contains.length + 1}"
      end

      def bare_druid
        @bare_druid ||= DruidTools::Druid.new(@dro.externalIdentifier).id
      end

      def content_dir
        @workspace_dir / 'content'
      end

      def document?
        @dro.type == Cocina::Models::ObjectType.document
      end
    end
  end
  # rubocop:enable Style/ClassLength
end
